{
  "problem": {
    "id": 105971,
    "difficulty": 5,
    "index": "A",
    "title": "Tokens on a Graph",
    "timeLimit": 4,
    "memLimit": 256,
    "description": "### Description\n\nYou are given a graph consisting of $n$ vertices numbered with integers from 1 to $n$, connected by $n+m$ edges. The first $n$ edges connect neighboring vertices, meaning the $i-th$ edge connects the $i-th$ and $(i+1)-th$ vertices, and the $n-th$ edge connects the $n-th$ and $1-st$ vertices. In some vertices, there are $n\u22122$ tokens numbered with integers from 1 to $n\u22122$, and no vertex can have more than one token.\n\nIn one move, you are allowed to move any token to a vertex connected by an edge to its current vertex, provided that there is currently no token in that vertex. For each token, you know which vertex it should end up in after all moves are completed.\n\nYour task is to determine the sequence of moves so that the tokens end up in the required positions. Note that minimizing the number of moves is not required.\n\n\n### Input\n\nEach test consists of several sets of input data. The first line contains a single integer $t (1\u2264t\u226420)$ \u2014 the number of sets of input data. The description of the sets of input data follows.\n\nIn the first line of each set of input data, two integers $n$ and $m$ $(4\u2264n\u2264100, 1\u2264m\u22642000)$ are given \u2014 the number of vertices and additional edges, respectively.\n\nThe second line contains $n\u22122$ integers $a_{i}$ $(1\u2264a_{i}\u2264n, a_{i}\u2260a_{j} for i\u2260j)$, where the $i-th$ number indicates the initial position of the $i-th$ token.\n\nThe third line contains $n\u22122$ integers $b_{i}$ $(1\u2264b_{i}\u2264n, b_{i}\u2260b_{j} for i\u2260j)$, where the $i-th$ number indicates the required position of the $i-th$ token.\n\nIn the following $m$ lines, two integers $u_{i}$ and $v_{i}$ $(1\u2264u_{i},v_{i}\u2264n,u_{i}\u2260v_{i})$ are given \u2014 the numbers of the vertices connected by an edge. It is guaranteed that the resulting graph does not contain multiple edges or self-loops.\n\nIt is guaranteed that the sum of $n$ across all sets of input data does not exceed 100.\n\n\n### Output\nFor each set of input data, output a single integer $k (k\u22650)$ in the first line \u2014 the number of moves. In the following k lines, output two integers $c_{i}$ and $p_{i}$ $(1\u2264c_{i}\u2264n\u22122, 1\u2264p_{i}\u2264n)$ \u2014 the token number and the vertex to which it should be moved on the $i-th$ move, respectively.\n\nThe total number of moves across all sets of input data must not exceed $2\u22c510^6$. It is guaranteed that such an answer always exists."
  },
  "submissions": {
    "333752325": {
      "id": 333752325,
      "creationTimeSeconds": 1755066526,
      "relativeTimeSeconds": 2147483647,
      "programmingLanguage": "Python 3",
      "verdict": "OK",
      "testset": "TESTS",
      "passedTestCount": 1,
      "timeConsumedMillis": 77,
      "memoryConsumedBytes": 3891200,
      "code": "import sys\nfrom collections import deque\n\n# ---------- \uc720\ud2f8: BFS\ub85c \uacbd\ub85c \uad6c\ud558\uae30 ----------\ndef bfs_path(start, goal, adj, blocked):\n    \"\"\"\n    start -> goal \uae4c\uc9c0\uc758 \uc815\uc810 \uacbd\ub85c(\ud3ec\ud568)\ub97c \ubc18\ud658.\n    blocked[v]\uac00 True\uc778 \uc815\uc810\uc740 \ud1b5\uacfc \ubd88\uac00. \ub2e8, goal\uc740 \ud56d\uc0c1 \ud1b5\uacfc \ud5c8\uc6a9.\n    start\ub3c4 \ud1b5\uacfc \ud5c8\uc6a9.\n    \"\"\"\n    if start == goal:\n        return [start]\n    n = len(adj) - 1\n    prev = [-1] * (n + 1)\n    q = deque([start])\n    prev[start] = -2  # \uc2dc\uc791 \ud45c\uc2dc\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if prev[v] != -1:\n                continue\n            if blocked[v] and v != goal:\n                continue\n            prev[v] = u\n            if v == goal:\n                # \uacbd\ub85c \ubcf5\uc6d0\n                path = []\n                cur = goal\n                while cur != -2:\n                    path.append(cur)\n                    cur = prev[cur]\n                path.reverse()\n                return path\n            q.append(v)\n    # \ubb38\uc81c \uc870\uac74\uc0c1 \ud56d\uc0c1 \uac00\ub2a5\n    raise RuntimeError(\"No path found (should not happen).\")\n\ndef bfs_to_make_empty(target, adj, blocked, empty_set):\n    \"\"\"\n    \ube48 \uce78\ub4e4\uc744 \ub3d9\uc2dc\uc5d0 \uc2dc\uc791\uc810\uc73c\ub85c \ud558\uc5ec target\uc744 \ube48 \uce78\uc73c\ub85c \ub9cc\ub4dc\ub294 \uacbd\ub85c(\ube48 \uce78 \uc774\ub3d9 \uacbd\ub85c)\ub97c \ubc18\ud658.\n    \ubc18\ud658\uc740 'source_empty -> ... -> target' \uc815\uc810 \ub9ac\uc2a4\ud2b8.\n    blocked[v]\uac00 True\uc778 \uacf3\uc740 \ud1b5\uacfc \uae08\uc9c0. \ub2e8, target\uc740 \ud5c8\uc6a9.\n    empty_set\uc740 \ud604\uc7ac \ube48 \uce78 2\uac1c\uc758 \uc9d1\ud569.\n    \"\"\"\n    if target in empty_set:\n        return [target]  # \uc774\ubbf8 \ube48 \uce78\n\n    n = len(adj) - 1\n    prev = [-1] * (n + 1)\n    q = deque()\n    # \ub450 \ube48 \uce78\uc744 \uba40\ud2f0 \uc18c\uc2a4\ub85c\n    for s in empty_set:\n        prev[s] = -2  # \uc18c\uc2a4 \ud45c\uc2dd\n        q.append(s)\n\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if prev[v] != -1:\n                continue\n            if blocked[v] and v != target:\n                continue\n            prev[v] = u\n            if v == target:\n                # \uacbd\ub85c \ubcf5\uc6d0\n                path = []\n                cur = target\n                while cur != -2:\n                    path.append(cur)\n                    cur = prev[cur]\n                path.reverse()\n                return path\n            q.append(v)\n    raise RuntimeError(\"No empty path (should not happen).\")\n\n# ---------- \uba54\uc778 \ud574\uacb0 ----------\ndef solve():\n    data = sys.stdin.read().strip().split()\n    it = iter(data)\n    t = int(next(it))\n    out_lines = []\n    for _case in range(t):\n        n = int(next(it)); m = int(next(it))\n        T = n - 2  # \ud1a0\ud070 \uc218\n\n        a = [int(next(it)) for _ in range(T)]\n        b = [int(next(it)) for _ in range(T)]\n\n        # \uadf8\ub798\ud504 \uc778\uc811\ub9ac\uc2a4\ud2b8(1-indexed)\n        adj = [set() for _ in range(n + 1)]\n        # \uc0ac\uc774\ud074 \uac04\uc120\n        for i in range(1, n + 1):\n            u = i\n            v = i + 1 if i < n else 1\n            adj[u].add(v)\n            adj[v].add(u)\n        # \ucd94\uac00 \uac04\uc120\n        for _ in range(m):\n            u = int(next(it)); v = int(next(it))\n            adj[u].add(v); adj[v].add(u)\n        # set -> list\n        adj = [list(nei) for nei in adj]\n\n        # \uc0ac\uc774\ud074\uc758 \uc21c\uc11c \uad00\ub9ac\uc6a9(next/prev)\n        nxt = [0] * (n + 1)\n        prv = [0] * (n + 1)\n        for i in range(1, n + 1):\n            nxt[i] = i + 1 if i < n else 1\n            prv[i] = i - 1 if i > 1 else n\n\n        # \uc810\uc720 \uc0c1\ud0dc \ubc0f \ud1a0\ud070 \uc704\uce58\n        occ = [0] * (n + 1)          # occ[v] = \ud1a0\ud070 \ubc88\ud638 \ub610\ub294 0(\ube48\uce78)\n        pos = [0] * (T + 1)          # pos[t] = \ud1a0\ud070 t\uc758 \ud604\uc7ac \uc815\uc810\n        for tkn in range(1, T + 1):\n            v = a[tkn - 1]\n            occ[v] = tkn\n            pos[tkn] = v\n\n        # \ud604\uc7ac \ube48 \uce78 2\uac1c\n        empty_set = set(v for v in range(1, n + 1) if occ[v] == 0)\n        assert len(empty_set) == 2\n\n        # \uac01 \uc815\uc810\uc758 \ubaa9\ud45c \ud1a0\ud070 id\n        token_by_target = [0] * (n + 1)\n        for tkn in range(1, T + 1):\n            token_by_target[b[tkn - 1]] = tkn\n\n        # \ucd5c\uc885 \ube48 \uce78 \uc704\uce58(\ubaa9\ud45c b\uc5d0 \uc5c6\ub294 \ub450 \uc815\uc810)\n        target_set = set(b)\n        final_empties = set(range(1, n + 1)) - target_set\n        assert len(final_empties) == 2\n\n        fixed = [False] * (n + 1)   # \uc774\ubbf8 \uc81c\uc790\ub9ac\uc5d0 \ub454 \uc815\uc810\n        fixed_cnt = 0\n\n        moves = []  # (token, to_vertex) \uc800\uc7a5\n\n        def record_move(token_id, to_v):\n            \"\"\"\ud1a0\ud070 token_id\ub97c to_v\ub85c \uc2e4\uc81c\ub85c \ud55c \uce78 \uc774\ub3d9(\uc778\uc811). \ube48\uce78/\uc810\uc720 \uac31\uc2e0.\"\"\"\n            from_v = pos[token_id]\n            # to_v\ub294 \ubc18\ub4dc\uc2dc \ud604\uc7ac \ube44\uc5b4 \uc788\uc5b4\uc57c \ud568\n            # \uc778\uc811\uc740 BFS \uad6c\uc131\uc0c1 \ubcf4\uc7a5\n            occ[from_v] = 0\n            occ[to_v] = token_id\n            pos[token_id] = to_v\n            # \ube48 \uce78 \uac31\uc2e0\n            empty_set.remove(to_v)\n            empty_set.add(from_v)\n            moves.append((token_id, to_v))\n\n        def make_empty_at(x, token_pos_to_avoid):\n            \"\"\"\uc815\uc810 x\ub97c \ube48 \uce78\uc73c\ub85c \ub9cc\ub4e0\ub2e4. (\ube48 \uce78 \uacbd\ub85c BFS \ud6c4 \uc2ac\ub77c\uc774\ub4dc \uc2e4\ud589)\"\"\"\n            if occ[x] == 0:\n                return\n            blocked = [False] * (n + 1)\n            for v in range(1, n + 1):\n                if fixed[v]:\n                    blocked[v] = True\n            blocked[token_pos_to_avoid] = True  # \ud604\uc7ac \uc804\uc9c4 \ud1a0\ud070 \uc704\uce58\ub294 \uac74\ub4dc\ub9ac\uc9c0 \uc54a\uc74c\n\n            path = bfs_to_make_empty(x, adj, blocked, empty_set)\n            # path: source_empty -> ... -> x\n            # \ube48 \uce78\uc744 \ud55c \uce78\uc529 x\ub85c \ubcf4\ub0b8\ub2e4: (\ub2e4\uc74c \uce78\uc758 \ud1a0\ud070\uc744 \ud604\uc7ac \ube48 \uce78\uc73c\ub85c \uc774\ub3d9)\n            for i in range(len(path) - 1):\n                u = path[i]      # \ud604\uc7ac \ube48\uce78\n                v = path[i + 1]  # \ub2e4\uc74c \uc815\uc810(\uc5ec\uae30 \ud1a0\ud070\uc744 u\ub85c \uc774\ub3d9)\n                tok = occ[v]\n                # v\uac00 \ube48\uce78\uc77c \uc77c\uc740 \uc5c6\uc74c(\uba40\ud2f0\uc18c\uc2a4 \ucc98\ub9ac\ub85c \ub0b4\ubd80 \uacbd\ub85c\uc5d0 \ub2e4\ub978 \ube48\uce78\uc774 \uc548 \uc7a1\ud788\uac8c \ub428)\n                # \ub2e8, target\uc774 \uc6d0\ub798 \ube48\uce78\uc774\uba74 path \uae38\uc774\uac00 1\uc774\ub77c \ub8e8\ud504 \ubbf8\uc2e4\ud589\n                if tok == 0:\n                    # \ubc29\uc5b4\uc801 \uccb4\ud06c(\uc774\uc0c1 \ucf00\uc774\uc2a4 \ubc29\uc9c0)\n                    continue\n                record_move(tok, u)\n            # \uc774\uc81c x\uac00 \ube48 \uce78\uc774 \ub428\n\n        def move_token_to_vertex(token_id, target_v):\n            \"\"\"\ud1a0\ud070 token_id\ub97c target_v\ub85c \ubcf4\ub0b8\ub2e4(\uc5ec\ub7ec \uce78, BFS \uacbd\ub85c \ub530\ub77c \ud55c \uce78\uc529).\"\"\"\n            # \ud1a0\ud070 \uc774\ub3d9 \uacbd\ub85c\ub294 \uace0\uc815 \uc815\uc810\ub9cc \ud53c\ud558\uba74 \ub428\n            blocked = [False] * (n + 1)\n            for v in range(1, n + 1):\n                if fixed[v]:\n                    blocked[v] = True\n            # \uacbd\ub85c \uad6c\ud558\uae30 (\ud1a0\ud070\uc758 \ud604\uc7ac \uc704\uce58 -> \ubaa9\ud45c \uc815\uc810)\n            path = bfs_path(pos[token_id], target_v, adj, blocked)\n            # \ud55c \uce78\uc529 \uc804\uc9c4\n            for i in range(1, len(path)):\n                step = path[i]\n                # \uba3c\uc800 step\uc744 \ube44\uc6b0\uae30\n                make_empty_at(step, pos[token_id])\n                # \uc774\uc81c \ud1a0\ud070\uc744 \ud55c \uce78 \uc774\ub3d9\n                record_move(token_id, step)\n            # target_v\uc5d0 \ub3c4\ucc29\n\n        # \uace0\uc815 \uad6c\uac04 \uc591 \ub05d(\uc0ac\uc774\ud074 \uae30\uc900). \ucc98\uc74c\uc5d4 \uc544\ubb34\uac83\ub3c4 \uc5c6\uc73c\ub2c8 \ud558\ub098 \ubf51\uc544 \uc2dc\uc791\uc810 \uc124\uce58\n        # final_empties\uac00 \uc544\ub2cc \uc784\uc758\uc758 \uc815\uc810 \ud558\ub098\ub97c \uba3c\uc800 \uace0\uc815\n        first_v = next(v for v in range(1, n + 1) if v not in final_empties)\n        first_token = token_by_target[first_v]\n        if pos[first_token] != first_v:\n            move_token_to_vertex(first_token, first_v)\n        fixed[first_v] = True\n        fixed_cnt += 1\n        L = R = first_v  # \uace0\uc815 \uad6c\uac04: L .. R (next \ubc29\ud5a5\uc73c\ub85c \uc5f0\uc18d)\n\n        # \uc774\ud6c4\uc5d0\ub294 \uace0\uc815 \uad6c\uac04\uc758 \uc591 \uc606\uc5d0\uc11c\ub9cc \ud655\uc7a5\n        while fixed_cnt < n - 2:\n            y1 = nxt[R]\n            y2 = prv[L]\n            pick = None\n            if not fixed[y1] and y1 not in final_empties:\n                pick = y1\n            elif not fixed[y2] and y2 not in final_empties:\n                pick = y2\n            else:\n                # \ub458 \ub2e4 \ucd5c\uc885 \ube48\uce78\uc774\uba74 \ub05d(\ub450 \uac1c \ub0a8\uc74c)\n                break\n\n            tkn = token_by_target[pick]\n            if pos[tkn] != pick:\n                move_token_to_vertex(tkn, pick)\n            fixed[pick] = True\n            fixed_cnt += 1\n            if pick == y1:\n                R = pick\n            else:\n                L = pick\n\n        # \ucd9c\ub825\n        out_lines.append(str(len(moves)))\n        out_lines.extend(f\"{c} {p}\" for c, p in moves)\n\n    print(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()\n"
    },
    "333746198": {
      "id": 333746198,
      "creationTimeSeconds": 1755062676,
      "relativeTimeSeconds": 2147483647,
      "programmingLanguage": "Python 3",
      "verdict": "RUNTIME_ERROR",
      "testset": "TESTS",
      "passedTestCount": 0,
      "timeConsumedMillis": 77,
      "memoryConsumedBytes": 2560000,
      "code": "import sys\n\n# --- \uc720\ud2f8 ---\n\ndef ceil_div(a, b):\n    return (a + b - 1) // b\n\ndef solve():\n    it = iter(sys.stdin.read().split())\n    t = int(next(it))\n    out = []\n\n    for _ in range(t):\n        n = int(next(it)); m = int(next(it))\n        a = [int(next(it)) for _ in range(n - 2)]\n        b = [int(next(it)) for _ in range(n - 2)]\n        for __ in range(m):\n            _u = next(it); _v = next(it)  # \ucd94\uac00 \uac04\uc120\uc740 \ubb34\uc2dc(\uc0ac\uc774\ud074\ub9cc \uc0ac\uc6a9)\n\n        # \uc0ac\uc774\ud074 \ubcf4\uc870\n        def inc(x):\n            y = x + 1\n            if y > n: y = 1\n            return y\n        def dec(x):\n            y = x - 1\n            if y < 1: y = n\n            return y\n        def dist_cw(u, v):\n            return (v - u) % n\n\n        # \ud604\uc7ac \uc810\uc720/\uc704\uce58\n        token_at = [0]*(n+1)   # \uc815\uc810 -> \ud1a0\ud070 (\uc5c6\uc73c\uba74 0)\n        pos_of   = [0]*(n-1)   # \ud1a0\ud070 -> \uc815\uc810\n        for i, v in enumerate(a, 1):\n            token_at[v] = i\n            pos_of[i] = v\n\n        # \ubaa9\ud45c: \uc815\uc810 -> \ub4e4\uc5b4\uac00\uc57c \ud560 \ud1a0\ud070 (\uc5c6\uc73c\uba74 0)\n        inv_target = [0]*(n+1)\n        for i, v in enumerate(b, 1):\n            inv_target[v] = i\n\n        # \ud604\uc7ac \ube48 \uce78(2\uac1c)\n        holes = [v for v in range(1, n+1) if token_at[v] == 0]\n        h1, h2 = holes[0], holes[1]\n\n        moves = []\n\n        # \ud55c \uce78 \uc2ac\ub77c\uc774\ub4dc: \"u -> v(\ube48\uce78)\" \uc73c\ub85c \ud1a0\ud070\uc744 \uc62e\uae34\ub2e4(\uc778\uc811\ud574\uc57c \ud568)\n        def slide_token(tok, v_from, v_to):\n            # v_to\ub294 \ubc18\ub4dc\uc2dc \ube48 \uce78\uc774\uc5b4\uc57c \ud558\uace0 v_from\uc740 \uc778\uc811\ud574\uc57c \ud568(\uc0ac\uc774\ud074 \uac04\uc120\ub9cc \uc0ac\uc6a9)\n            # \uc778\uc811\uc131 \uccb4\ud06c\ub294 \ud638\ucd9c\ubd80\uc5d0\uc11c\ub9cc \ubcf4\uc7a5(\uc5ec\uae30\uc11c\ub294 \uae30\ub85d\ub9cc)\n            moves.append((tok, v_to))\n            token_at[v_to] = tok\n            token_at[v_from] = 0\n            pos_of[tok] = v_to\n\n        # 1) \ub450 \ube48 \uce78\uc744 \uc778\uc811\ud558\uac8c \ub9cc\ub4e0\ub2e4.\n        while not (inc(h1) == h2 or inc(h2) == h1):\n            # \ub354 \uc9e7\uc740 \ubc29\ud5a5\uc73c\ub85c h1\uc744 h2 \ucabd\uc73c\ub85c \ub2f9\uae34\ub2e4(\ub3d9\ub960\uc774\uba74 h1\uc744 \uc774\ub3d9)\n            if dist_cw(h1, h2) <= dist_cw(h2, h1):\n                x = inc(h1)\n                tok = token_at[x]\n                assert tok != 0\n                slide_token(tok, x, h1)\n                h1 = x\n            else:\n                x = inc(h2)\n                tok = token_at[x]\n                assert tok != 0\n                slide_token(tok, x, h2)\n                h2 = x\n\n        # \uc778\uc811\ud574\uc84c\uc73c\uba74 \ub77c\uc778\uc758 \uc591 \ub05d(L, R) \uacb0\uc815(\uae34 \ucabd\uc774 \ub418\ub3c4\ub85d)\n        if inc(h1) == h2:\n            L, R = h2, h1\n        else:\n            L, R = h1, h2\n\n        # \ub77c\uc778 \uad6c\uc131: [L, L+1, ..., R] (R \ub2e4\uc74c\uc774 L\uc774 \ub418\uc9c0 \uc54a\ub294 \uae34 \ucabd)\n        line = []\n        x = L\n        while True:\n            line.append(x)\n            if x == R: break\n            x = inc(x)\n\n        idx = {v:i for i,v in enumerate(line)}  # \uc815\uc810 -> \ub77c\uc778 \uc778\ub371\uc2a4\n\n        # \ub77c\uc778 \ub0b4\ubd80(\uc591 \ub05d \uc81c\uc678)\uac00 \uc815\ud655\ud788 n-2\uac1c\n        assert len(line) == n - 1\n\n        # \ud604\uc7ac holes \uac31\uc2e0(\uc815\ub82c\uc740 \uc0c1\uad00\uc5c6\uc74c)\n        holes = [v for v in range(1, n+1) if token_at[v] == 0]\n        # \ub450 \ube48\uce78\uc774 \uc815\ub9d0 \ub77c\uc778\uc758 \ub05d\uc810\uc5d0 \uc788\uc5b4\uc57c \ud568(\uc778\uc811 \ub9cc\ub4e4\uae30\uc5d0\uc11c \uadf8\ub807\uac8c \ub428)\n        assert set(holes) == {h1, h2}\n        assert (h1 in (L, R)) and (h2 in (L, R))\n\n        # \ubcf4\uc870: \ub77c\uc778 \ub0b4\uc5d0\uc11c 'u'\ub85c \ube48\uce78 \ud558\ub098\ub97c \ub370\ub824\uc628\ub2e4.\n        # \uc774\ubbf8 \ubc30\uce58\ud55c prefix(\uc778\ub371\uc2a4 < min_idx)\ub294 \uac74\ub4dc\ub9ac\uc9c0 \uc54a\ub294\ub2e4.\n        # \ub610\ud55c \ud1a0\ud070 p\uc758 \uc67c\ucabd(= u \ucabd)\uc5d0\uc11c\ub9cc \ube48\uce78\uc744 \ub04c\uc5b4\uc628\ub2e4(\ub118\uc5b4\uac00\uc9c0 \uc54a\uac8c).\n        def move_hole_to(u, p=None, min_idx=0):\n            nonlocal holes\n            up = idx[u]\n            i1 = idx[holes[0]]\n            i2 = idx[holes[1]]\n\n            if holes[0] == u or holes[1] == u:\n                return\n\n            def valid_side(i):\n                if p is None: return True\n                pp = idx[p]\n                # u\ub294 p\uc758 \uc67c\ucabd(\ud55c \uce78 \ud639\uc740 \ub354 \uc67c\ucabd)\uc5d0 \uc788\uc73c\ubbc0\ub85c,\n                # \ube48\uce78 \ucd9c\ubc1c\uc810\ub3c4 p\uc758 \uc67c\ucabd \uad6c\uac04\uc5d0\uc11c\ub9cc \uc120\ud0dd\n                return i <= pp - 1\n\n            cands = []\n            for hid, ii in [(0, i1), (1, i2)]:\n                if ii >= min_idx and valid_side(ii):\n                    cands.append((abs(ii - up), hid, ii))\n            if not cands:\n                # \uc608\uc678\uc801\uc73c\ub85c p \uc81c\uc57d\uc744 \ud480\uace0 prefix\ub9cc \ubcf4\ud638\n                for hid, ii in [(0, i1), (1, i2)]:\n                    if ii >= min_idx:\n                        cands.append((abs(ii - up), hid, ii))\n                assert cands\n\n            cands.sort()\n            _, active, i = cands[0]\n            other = 1 - active\n\n            while i != up:\n                step = 1 if up > i else -1\n                j = i + step\n                vj = line[j]\n                vi = line[i]\n\n                # \ub2e4\uc74c \uce78\uc774 \ub2e4\ub978 \ube48\uce78\uc774\uba74 \uc561\ud2f0\ube0c \ud640\uc744 \uc2a4\uc704\uce58\n                if vj == holes[other]:\n                    i = j\n                    active, other = other, active\n                    continue\n\n                # vj\uc758 \ud1a0\ud070\uc744 vi(\ud604\uc7ac \ube48\uce78)\ub85c \ud55c \uce78 \uc2ac\ub77c\uc774\ub4dc\n                tok = token_at[vj]\n                assert tok != 0\n                slide_token(tok, vj, vi)\n                # \uc774\uc81c \ube48\uce78\uc774 vj\ub85c \uc774\ub3d9\n                holes[active] = vj\n                i = j\n\n        # \ub77c\uc778 \uc55e\ucabd \ub450 \uce78\uc744 \ube48\uce78\uc73c\ub85c \ub9de\ucdb0\ub450\uba74(= L, L+1) \uc774\ud6c4\uac00 \ud3b8\ud558\ub2e4.\n        move_hole_to(L, p=None, min_idx=0)\n        move_hole_to(line[1], p=L, min_idx=0)\n\n        # \ub0b4\ubd80 \uc804\uccb4(= n-2\uac1c)\ub97c \uc67c\ucabd\uc73c\ub85c \ubc00\uc5b4 \ubaa9\ud45c \uc815\uc810\uc5d0 \ubc30\uce58\n        for v in line[1:-1]:\n            want = inv_target[v]\n            # v\uac00 \ubaa9\ud45c\uac00 \uc544\ub2c8\ub77c\uba74(\uc774\ub860\uc0c1 \uc5c6\uc74c) \uac74\ub108\ub700\n            if want == 0:\n                continue\n            p = pos_of[want]\n            # \ud56d\uc0c1 p\ub294 v\uc758 \uc624\ub978\ucabd(= \uc778\ub371\uc2a4\uac00 \ub354 \ud07c) \ucabd\uc5d0 \uc788\uac8c \ub41c\ub2e4(\ubd88\ubcc0\uc2dd)\n            while p != v:\n                pi = idx[p]\n                u = line[pi - 1]  # \uc67c\ucabd \uc774\uc6c3\n                min_idx = idx[v]\n                move_hole_to(u, p=p, min_idx=min_idx)\n                # \uc774\uc81c p -> u \ud55c \uce78 \uc774\ub3d9\n                slide_token(want, p, u)\n                # \ube48\uce78 \uc704\uce58 \uac31\uc2e0(\uc9c0\uae08 \uc774\ub3d9\uc5d0 \uc0ac\uc6a9\ud55c \ube48\uce78\uc740 u\uc5d0 \uc788\uc5c8\uc74c)\n                if holes[0] == u:\n                    holes[0] = p\n                else:\n                    assert holes[1] == u\n                    holes[1] = p\n                p = u\n\n        # \ucd9c\ub825\n        out.append(str(len(moves)))\n        for tok, to in moves:\n            out.append(f\"{tok} {to}\")\n\n    print(\"\\n\".join(out))\n\n\nif __name__ == \"__main__\":\n    solve()\n"
    },
    "333745249": {
      "id": 333745249,
      "creationTimeSeconds": 1755062012,
      "relativeTimeSeconds": 2147483647,
      "programmingLanguage": "Python 3",
      "verdict": "WRONG_ANSWER",
      "testset": "TESTS",
      "passedTestCount": 0,
      "timeConsumedMillis": 62,
      "memoryConsumedBytes": 716800,
      "code": "import sys\n\ndef solve():\n    it = iter(sys.stdin.read().split())\n    t = int(next(it))\n    out_lines = []\n    all_moves = []\n\n    for _ in range(t):\n        n = int(next(it)); m = int(next(it))\n        a = [int(next(it)) for _ in range(n-2)]\n        b = [int(next(it)) for _ in range(n-2)]\n        # read and ignore extra edges (we only use the cycle edges)\n        for __ in range(m):\n            _u = next(it); _v = next(it)\n\n        # occupancy\n        token_at = [0]*(n+1)          # 0 if empty, else token id\n        pos_of = [0]*(n-1)            # token id -> vertex (1..n)\n        for i, v in enumerate(a, 1):\n            token_at[v] = i\n            pos_of[i] = v\n\n        # inverse targets: which token belongs at vertex v\n        inv_target = [0]*(n+1)\n        for i, v in enumerate(b, 1):\n            inv_target[v] = i\n\n        # final empty vertices = not in b\n        allv = set(range(1, n+1))\n        holes_final = list(allv - set(b))  # size 2\n        h1, h2 = holes_final[0], holes_final[1]\n\n        # choose orientation so that walking +1 from L to R covers n-2 vertices\n        def inc(x): \n            y = x + 1\n            if y > n: y = 1\n            return y\n        def dec(x):\n            y = x - 1\n            if y < 1: y = n\n            return y\n\n        # distance clockwise from u to v (#steps of inc to reach v)\n        def dist_cw(u, v):\n            if v >= u: return v - u\n            return v + n - u\n\n        if dist_cw(h1, h2) == 1:\n            L, R = h2, h1\n        else:\n            L, R = h1, h2\n\n        # Build the linear order \"line\": [L, L+1, ..., R] (no wrap between R->L)\n        line = []\n        x = L\n        while True:\n            line.append(x)\n            if x == R:\n                break\n            x = inc(x)\n\n        idx = {v: i for i, v in enumerate(line)}  # vertex -> index in line\n\n        # The vertices to place (in order) are line[1:-1]\n        place_order = line[1:-1]\n\n        # current holes (empty vertices) from a\n        holes = [v for v in range(1, n+1) if token_at[v] == 0]\n        assert len(holes) == 2\n\n        moves = []\n\n        # Helper: move one hole to target vertex \"u\" along the path \"line\",\n        # without crossing into already-placed prefix (min_idx = index of current v),\n        # and without crossing the chosen token position p (so we always stay\n        # in the same side of p as u).\n        def move_hole_to(u, p=None, min_idx=0):\n            nonlocal holes, token_at, pos_of, moves\n            up = idx[u]\n            i1 = idx[holes[0]]\n            i2 = idx[holes[1]]\n\n            # If one hole already there, done.\n            if holes[0] == u or holes[1] == u:\n                return\n\n            # decide the component side relative to p (if provided)\n            def valid_side(i):\n                if p is None:\n                    return True\n                pp = idx[p]\n                if up < pp:\n                    return i <= pp - 1\n                else:\n                    return i >= pp + 1\n\n            candidates = []\n            for hid, ii in [(0, i1), (1, i2)]:\n                if ii >= min_idx and valid_side(ii):\n                    candidates.append((abs(ii - up), hid, ii))\n            # In our flow there should always be at least one candidate\n            if not candidates:\n                # Fallback: if something unexpected, ignore p constraint\n                for hid, ii in [(0, i1), (1, i2)]:\n                    if ii >= min_idx:\n                        candidates.append((abs(ii - up), hid, ii))\n                assert candidates, \"No hole available to move.\"\n\n            candidates.sort()\n            _, active, i = candidates[0]\n            other = 1 - active\n            other_i = idx[holes[other]]\n\n            while i != up:\n                step = 1 if up > i else -1\n                j = i + step\n                vj = line[j]\n\n                # if next step is the other hole, just \"switch\" active hole\n                if vj == holes[other]:\n                    i = j\n                    active, other = other, active\n                    other_i = idx[holes[other]]\n                    continue\n\n                # move token from vj -> line[i] (the current hole position)\n                tok = token_at[vj]\n                assert tok != 0, \"Unexpected empty encountered.\"\n                vi = line[i]\n                # perform move\n                moves.append((tok, vi))\n                token_at[vi] = tok\n                token_at[vj] = 0\n                pos_of[tok] = vi\n                # hole has moved to vj\n                holes[active] = vj\n                i = j\n\n        # Prepare: put both holes to the very left side (L and L+1),\n        # so we never need to cross placed prefix later.\n        move_hole_to(L, p=None, min_idx=0)\n        move_hole_to(line[1], p=L, min_idx=0)  # moves the \"other\" hole to L+1\n\n        # Place tokens from left to right along the path\n        for v in place_order:\n            want = inv_target[v]          # token id that must end at v\n            p = pos_of[want]              # current position of that token\n            while p != v:\n                pi = idx[p]\n                # move to its left neighbor in the path\n                u = line[pi - 1]          # left neighbor exists because p != v\n                # ensure a hole at u; restrict holes to the unprocessed suffix\n                min_idx = idx[v]          # never cross placed prefix [1..idx[v]-1]\n                move_hole_to(u, p=p, min_idx=min_idx)\n                # now move the token one step left: p -> u\n                moves.append((want, u))\n                token_at[u] = want\n                token_at[p] = 0\n                pos_of[want] = u\n                # update which hole moved: the hole currently at u becomes at p\n                if holes[0] == u:\n                    holes[0] = p\n                else:\n                    assert holes[1] == u\n                    holes[1] = p\n                p = u\n\n        # collect output\n        out_lines.append(str(len(moves)))\n        all_moves.extend(moves)\n\n        for tok, where in moves:\n            out_lines.append(f\"{tok} {where}\")\n\n    print(\"\\n\".join(out_lines))\n\n\nif __name__ == \"__main__\":\n    solve()\n"
    },
    "336073028": {
      "id": 336073028,
      "creationTimeSeconds": 1756434196,
      "relativeTimeSeconds": 2147483647,
      "programmingLanguage": "Python 3",
      "verdict": "WRONG_ANSWER",
      "testset": "TESTS",
      "passedTestCount": 0,
      "timeConsumedMillis": 62,
      "memoryConsumedBytes": 614400,
      "code": "import sys\ndef solve():\n    it = iter(sys.stdin.read().split())\n    t = int(next(it))\n    out_lines = []\n    all_moves = []\n    for _ in range(t):\n        n = int(next(it)); m = int(next(it))\n        a = [int(next(it)) for _ in range(n-2)]\n        b = [int(next(it)) for _ in range(n-2)]\n        # read and ignore extra edges (we only use the cycle edges)\n        for __ in range(m):\n            _u = next(it); _v = next(it)\n         # occupancy\n        token_at = [0]*(n+1)          # 0 if empty, else token id\n        pos_of = [0]*(n-1)            # token id -> vertex (1..n)\n        for i, v in enumerate(a, 1):\n            token_at[v] = i\n            pos_of[i] = v\n         # inverse targets: which token belongs at vertex v\n        inv_target = [0]*(n+1)\n        for i, v in enumerate(b, 1):\n            inv_target[v] = i\n         # final empty vertices = not in b\n        allv = set(range(1, n+1))\n        holes_final = list(allv - set(b))  # size 2\n        h1, h2 = holes_final[0], holes_final[1]\n         # choose orientation so that walking +1 from L to R covers n-2 vertices\n        def inc(x): \n            y = x + 1\n            if y > n: y = 1\n            return y\n        def dec(x):\n            y = x - 1\n            if y < 1: y = n\n            return y\n         # distance clockwise from u to v (#steps of inc to reach v)\n        def dist_cw(u, v):\n            if v >= u: return v - u\n            return v + n - u\n        if dist_cw(h1, h2) == 1:\n            L, R = h2, h1\n        else:\n            L, R = h1, h2\n         # Build the linear order \"line\": [L, L+1, ..., R] (no wrap between R->L)\n        line = []\n        x = L\n        while True:\n            line.append(x)\n            if x == R:\n                break\n            x = inc(x)\n        idx = {v: i for i, v in enumerate(line)}  # vertex -> index in line\n        # The vertices to place (in order) are line[1:-1]\n        place_order = line[1:-1]\n         # current holes (empty vertices) from a\n        holes = [v for v in range(1, n+1) if token_at[v] == 0]\n        assert len(holes) == 2\n        moves = []\n        # Helper: move one hole to target vertex \"u\" along the path \"line\",\n        # without crossing into already-placed prefix (min_idx = index of current v),\n        # and without crossing the chosen token position p (so we always stay\n        # in the same side of p as u).\n        def move_hole_to(u, p=None, min_idx=0):\n            nonlocal holes, token_at, pos_of, moves\n            up = idx[u]\n            i1 = idx[holes[0]]\n            i2 = idx[holes[1]]\n             # If one hole already there, done.\n            if holes[0] == u or holes[1] == u:\n                return\n             # decide the component side relative to p (if provided)\n            def valid_side(i):\n                if p is None:\n                    return True\n                pp = idx[p]\n                if up < pp:\n                    return i <= pp - 1\n                else:\n                    return i >= pp + 1\n            candidates = []\n            for hid, ii in [(0, i1), (1, i2)]:\n                if ii >= min_idx and valid_side(ii):\n                    candidates.append((abs(ii - up), hid, ii))\n            # In our flow there should always be at least one candidate\n            if not candidates:\n                # Fallback: if something unexpected, ignore p constraint\n                for hid, ii in [(0, i1), (1, i2)]:\n                    if ii >= min_idx:\n                        candidates.append((abs(ii - up), hid, ii))\n                assert candidates, \"No hole available to move.\"\n            candidates.sort()\n            _, active, i = candidates[0]\n            other = 1 - active\n            other_i = idx[holes[other]]\n            while i != up:\n                step = 1 if up > i else -1\n                j = i + step\n                vj = line[j]\n                 # if next step is the other hole, just \"switch\" active hole\n                if vj == holes[other]:\n                    i = j\n                    active, other = other, active\n                    other_i = idx[holes[other]]\n                    continue\n                 # move token from vj -> line[i] (the current hole position)\n                tok = token_at[vj]\n                assert tok != 0, \"Unexpected empty encountered.\"\n                vi = line[i]\n                # perform move\n                moves.append((tok, vi))\n                token_at[vi] = tok\n                token_at[vj] = 0\n                pos_of[tok] = vi\n                # hole has moved to vj\n                holes[active] = vj\n                i = j\n         # Prepare: put both holes to the very left side (L and L+1),\n        # so we never need to cross placed prefix later.\n        move_hole_to(L, p=None, min_idx=0)\n        move_hole_to(line[1], p=L, min_idx=0)  # moves the \"other\" hole to L+1\n         # Place tokens from left to right along the path\n        for v in place_order:\n            want = inv_target[v]          # token id that must end at v\n            p = pos_of[want]              # current position of that token\n            while p != v:\n                pi = idx[p]\n                # move to its left neighbor in the path\n                u = line[pi - 1]          # left neighbor exists because p != v\n                # ensure a hole at u; restrict holes to the unprocessed suffix\n                min_idx = idx[v]          # never cross placed prefix [1..idx[v]-1]\n                move_hole_to(u, p=p, min_idx=min_idx)\n                # now move the token one step left: p -> u\n                moves.append((want, u))\n                token_at[u] = want\n                token_at[p] = 0\n                pos_of[want] = u\n                # update which hole moved: the hole currently at u becomes at p\n                if holes[0] == u:\n                    holes[0] = p\n                else:\n                    assert holes[1] == u\n                    holes[1] = p\n                p = u\n         # collect output\n        out_lines.append(str(len(moves)))\n        all_moves.extend(moves)\n        for tok, where in moves:\n            out_lines.append(f\"{tok} {where}\")\n    print(\"\\n\".join(out_lines))\nif __name__ == \"__main__\":\n    solve()"
    },
    "327494892": {
      "id": 327494892,
      "creationTimeSeconds": 1751706423,
      "relativeTimeSeconds": 423,
      "programmingLanguage": "Python 3",
      "verdict": "RUNTIME_ERROR",
      "testset": "TESTS",
      "passedTestCount": 1,
      "timeConsumedMillis": 77,
      "memoryConsumedBytes": 2457600,
      "code": "import sys\ndef solve():\n    it = iter(sys.stdin.read().split())\n    t = int(next(it))\n    out_lines = []\n    all_moves = []\n    for _ in range(t):\n        n = int(next(it)); m = int(next(it))\n        a = [int(next(it)) for _ in range(n-2)]\n        b = [int(next(it)) for _ in range(n-2)]\n        # read and ignore extra edges (we only use the cycle edges)\n        for __ in range(m):\n            _u = next(it); _v = next(it)\n         # occupancy\n        token_at = [0]*(n+1)          # 0 if empty, else token id\n        pos_of = [0]*(n-1)            # token id -> vertex (1..n)\n        for i, v in enumerate(a, 1):\n            token_at[v] = i\n            pos_of[i] = v\n         # inverse targets: which token belongs at vertex v\n        inv_target = [0]*(n+1)\n        for i, v in enumerate(b, 1):\n            inv_target[v] = i\n         # final empty vertices = not in b\n        allv = set(range(1, n+1))\n        holes_final = list(allv - set(b))  # size 2\n        h1, h2 = holes_final[0], holes_final[1]\n         # choose orientation so that walking +1 from L to R covers n-2 vertices\n        def inc(x): \n            y = x + 1\n            if y > n: y = 1\n            return y\n        def dec(x):\n            y = x - 1\n            if y < 1: y = n\n            return y\n         # distance clockwise from u to v (#steps of inc to reach v)\n        def dist_cw(u, v):\n            if v >= u: return v - u\n            return v + n - u\n        if dist_cw(h1, h2) == 1:\n            L, R = h2, h1\n        else:\n            L, R = h1, h2\n         # Build the linear order \"line\": [L, L+1, ..., R] (no wrap between R->L)\n        line = []\n        x = L\n        while True:\n            line.append(x)\n            if x == R:\n                break\n            x = inc(x)\n        idx = {v: i for i, v in enumerate(line)}  # vertex -> index in line\n        # The vertices to place (in order) are line[1:-1]\n        place_order = line[1:-1]\n         # current holes (empty vertices) from a\n        holes = [v for v in range(1, n+1) if token_at[v] == 0]\n        assert len(holes) == 2\n        moves = []\n        # Helper: move one hole to target vertex \"u\" along the path \"line\",\n        # without crossing into already-placed prefix (min_idx = index of current v),\n        # and without crossing the chosen token position p (so we always stay\n        # in the same side of p as u).\n        def move_hole_to(u, p=None, min_idx=0):\n            nonlocal holes, token_at, pos_of, moves\n            up = idx[u]\n            i1 = idx[holes[0]]\n            i2 = idx[holes[1]]\n             # If one hole already there, done.\n            if holes[0] == u or holes[1] == u:\n                return\n             # decide the component side relative to p (if provided)\n            def valid_side(i):\n                if p is None:\n                    return True\n                pp = idx[p]\n                if up < pp:\n                    return i <= pp - 1\n                else:\n                    return i >= pp + 1\n            candidates = []\n            for hid, ii in [(0, i1), (1, i2)]:\n                if ii >= min_idx and valid_side(ii):\n                    candidates.append((abs(ii - up), hid, ii))\n            # In our flow there should always be at least one candidate\n            if not candidates:\n                # Fallback: if something unexpected, ignore p constraint\n                for hid, ii in [(0, i1), (1, i2)]:\n                    if ii >= min_idx:\n                        candidates.append((abs(ii - up), hid, ii))\n                assert candidates, \"No hole available to move.\"\n            candidates.sort()\n            _, active, i = candidates[0]\n            other = 1 - active\n            other_i = idx[holes[other]]\n            while i != up:\n                step = 1 if up > i else -1\n                j = i + step\n                vj = line[j]\n                 # if next step is the other hole, just \"switch\" active hole\n                if vj == holes[other]:\n                    i = j\n                    active, other = other, active\n                    other_i = idx[holes[other]]\n                    continue\n                 # move token from vj -> line[i] (the current hole position)\n                tok = token_at[vj]\n                assert tok != 0, \"Unexpected empty encountered.\"\n                vi = line[i]\n                # perform move\n                moves.append((tok, vi))\n                token_at[vi] = tok\n                token_at[vj] = 0\n                pos_of[tok] = vi\n                # hole has moved to vj\n                holes[active] = vj\n                i = j\n         # Prepare: put both holes to the very left side (L and L+1),\n        # so we never need to cross placed prefix later.\n        move_hole_to(L, p=None, min_idx=0)\n        move_hole_to(line[1], p=L, min_idx=0)  # moves the \"other\" hole to L+1\n         # Place tokens from left to right along the path\n        for v in place_order:\n            want = inv_target[v]          # token id that must end at v\n            p = pos_of[want]              # current position of that token\n            while p != v:\n                pi = idx[p]\n                # move to its left neighbor in the path\n                u = line[pi - 1]          # left neighbor exists because p != v\n                # ensure a hole at u; restrict holes to the unprocessed suffix\n                min_idx = idx[v]          # never cross placed prefix [1..idx[v]-1]\n                move_hole_to(u, p=p, min_idx=min_idx)\n                # now move the token one step left: p -> u\n                moves.append((want, u))\n                token_at[u] = want\n                token_at[p] = 0\n                pos_of[want] = u\n                # update which hole moved: the hole currently at u becomes at p\n                if holes[0] == u:\n                    holes[0] = p\n                else:\n                    assert holes[1] == u\n                    holes[1] = p\n                p = u\n         # collect output\n        out_lines.append(str(len(moves)))\n        all_moves.extend(moves)\n        for tok, where in moves:\n            out_lines.append(f\"{tok} {where}\")\n    print(\"\\n\".join(out_lines))\nif __name__ == \"__main__\":\n    solve()"
    },
    "327494640": {
      "id": 327494640,
      "creationTimeSeconds": 1751706306,
      "relativeTimeSeconds": 306,
      "programmingLanguage": "Python 3",
      "verdict": "RUNTIME_ERROR",
      "testset": "TESTS",
      "passedTestCount": 1,
      "timeConsumedMillis": 78,
      "memoryConsumedBytes": 2560000,
      "code": "import sys\ndef solve():\n    it = iter(sys.stdin.read().split())\n    t = int(next(it))\n    out_lines = []\n    all_moves = []\n    for _ in range(t):\n        n = int(next(it)); m = int(next(it))\n        a = [int(next(it)) for _ in range(n-2)]\n        b = [int(next(it)) for _ in range(n-2)]\n        # read and ignore extra edges (we only use the cycle edges)\n        for __ in range(m):\n            _u = next(it); _v = next(it)\n         # occupancy\n        token_at = [0]*(n+1)          # 0 if empty, else token id\n        pos_of = [0]*(n-1)            # token id -> vertex (1..n)\n        for i, v in enumerate(a, 1):\n            token_at[v] = i\n            pos_of[i] = v\n         # inverse targets: which token belongs at vertex v\n        inv_target = [0]*(n+1)\n        for i, v in enumerate(b, 1):\n            inv_target[v] = i\n         # final empty vertices = not in b\n        allv = set(range(1, n+1))\n        holes_final = list(allv - set(b))  # size 2\n        h1, h2 = holes_final[0], holes_final[1]\n         # choose orientation so that walking +1 from L to R covers n-2 vertices\n        def inc(x): \n            y = x + 1\n            if y > n: y = 1\n            return y\n        def dec(x):\n            y = x - 1\n            if y < 1: y = n\n            return y\n         # distance clockwise from u to v (#steps of inc to reach v)\n        def dist_cw(u, v):\n            if v >= u: return v - u\n            return v + n - u\n        if dist_cw(h1, h2) == 1:\n            L, R = h2, h1\n        else:\n            L, R = h1, h2\n         # Build the linear order \"line\": [L, L+1, ..., R] (no wrap between R->L)\n        line = []\n        x = L\n        while True:\n            line.append(x)\n            if x == R:\n                break\n            x = inc(x)\n        idx = {v: i for i, v in enumerate(line)}  # vertex -> index in line\n        # The vertices to place (in order) are line[1:-1]\n        place_order = line[1:-1]\n         # current holes (empty vertices) from a\n        holes = [v for v in range(1, n+1) if token_at[v] == 0]\n        assert len(holes) == 2\n        moves = []\n        # Helper: move one hole to target vertex \"u\" along the path \"line\",\n        # without crossing into already-placed prefix (min_idx = index of current v),\n        # and without crossing the chosen token position p (so we always stay\n        # in the same side of p as u).\n        def move_hole_to(u, p=None, min_idx=0):\n            nonlocal holes, token_at, pos_of, moves\n            up = idx[u]\n            i1 = idx[holes[0]]\n            i2 = idx[holes[1]]\n             # If one hole already there, done.\n            if holes[0] == u or holes[1] == u:\n                return\n             # decide the component side relative to p (if provided)\n            def valid_side(i):\n                if p is None:\n                    return True\n                pp = idx[p]\n                if up < pp:\n                    return i <= pp - 1\n                else:\n                    return i >= pp + 1\n            candidates = []\n            for hid, ii in [(0, i1), (1, i2)]:\n                if ii >= min_idx and valid_side(ii):\n                    candidates.append((abs(ii - up), hid, ii))\n            # In our flow there should always be at least one candidate\n            if not candidates:\n                # Fallback: if something unexpected, ignore p constraint\n                for hid, ii in [(0, i1), (1, i2)]:\n                    if ii >= min_idx:\n                        candidates.append((abs(ii - up), hid, ii))\n                assert candidates, \"No hole available to move.\"\n            candidates.sort()\n            _, active, i = candidates[0]\n            other = 1 - active\n            other_i = idx[holes[other]]\n            while i != up:\n                step = 1 if up > i else -1\n                j = i + step\n                vj = line[j]\n                 # if next step is the other hole, just \"switch\" active hole\n                if vj == holes[other]:\n                    i = j\n                    active, other = other, active\n                    other_i = idx[holes[other]]\n                    continue\n                 # move token from vj -> line[i] (the current hole position)\n                tok = token_at[vj]\n                assert tok != 0, \"Unexpected empty encountered.\"\n                vi = line[i]\n                # perform move\n                moves.append((tok, vi))\n                token_at[vi] = tok\n                token_at[vj] = 0\n                pos_of[tok] = vi\n                # hole has moved to vj\n                holes[active] = vj\n                i = j\n         # Prepare: put both holes to the very left side (L and L+1),\n        # so we never need to cross placed prefix later.\n        move_hole_to(L, p=None, min_idx=0)\n        move_hole_to(line[1], p=L, min_idx=0)  # moves the \"other\" hole to L+1\n         # Place tokens from left to right along the path\n        for v in place_order:\n            want = inv_target[v]          # token id that must end at v\n            p = pos_of[want]              # current position of that token\n            while p != v:\n                pi = idx[p]\n                # move to its left neighbor in the path\n                u = line[pi - 1]          # left neighbor exists because p != v\n                # ensure a hole at u; restrict holes to the unprocessed suffix\n                min_idx = idx[v]          # never cross placed prefix [1..idx[v]-1]\n                move_hole_to(u, p=p, min_idx=min_idx)\n                # now move the token one step left: p -> u\n                moves.append((want, u))\n                token_at[u] = want\n                token_at[p] = 0\n                pos_of[want] = u\n                # update which hole moved: the hole currently at u becomes at p\n                if holes[0] == u:\n                    holes[0] = p\n                else:\n                    assert holes[1] == u\n                    holes[1] = p\n                p = u\n         # collect output\n        out_lines.append(str(len(moves)))\n        all_moves.extend(moves)\n        for tok, where in moves:\n            out_lines.append(f\"{tok} {where}\")\n    print(\"\\n\".join(out_lines))\nif __name__ == \"__main__\":\n    solve()"
    },
    "327494423": {
      "id": 327494423,
      "creationTimeSeconds": 1751706194,
      "relativeTimeSeconds": 194,
      "programmingLanguage": "Python 3",
      "verdict": "WRONG_ANSWER",
      "testset": "TESTS",
      "passedTestCount": 0,
      "timeConsumedMillis": 46,
      "memoryConsumedBytes": 614400,
      "code": "import sys\ndef solve():\n    it = iter(sys.stdin.read().split())\n    t = int(next(it))\n    out_lines = []\n    all_moves = []\n    for _ in range(t):\n        n = int(next(it)); m = int(next(it))\n        a = [int(next(it)) for _ in range(n-2)]\n        b = [int(next(it)) for _ in range(n-2)]\n        # read and ignore extra edges (we only use the cycle edges)\n        for __ in range(m):\n            _u = next(it); _v = next(it)\n         # occupancy\n        token_at = [0]*(n+1)          # 0 if empty, else token id\n        pos_of = [0]*(n-1)            # token id -> vertex (1..n)\n        for i, v in enumerate(a, 1):\n            token_at[v] = i\n            pos_of[i] = v\n         # inverse targets: which token belongs at vertex v\n        inv_target = [0]*(n+1)\n        for i, v in enumerate(b, 1):\n            inv_target[v] = i\n         # final empty vertices = not in b\n        allv = set(range(1, n+1))\n        holes_final = list(allv - set(b))  # size 2\n        h1, h2 = holes_final[0], holes_final[1]\n         # choose orientation so that walking +1 from L to R covers n-2 vertices\n        def inc(x): \n            y = x + 1\n            if y > n: y = 1\n            return y\n        def dec(x):\n            y = x - 1\n            if y < 1: y = n\n            return y\n         # distance clockwise from u to v (#steps of inc to reach v)\n        def dist_cw(u, v):\n            if v >= u: return v - u\n            return v + n - u\n        if dist_cw(h1, h2) == 1:\n            L, R = h2, h1\n        else:\n            L, R = h1, h2\n         # Build the linear order \"line\": [L, L+1, ..., R] (no wrap between R->L)\n        line = []\n        x = L\n        while True:\n            line.append(x)\n            if x == R:\n                break\n            x = inc(x)\n        idx = {v: i for i, v in enumerate(line)}  # vertex -> index in line\n        # The vertices to place (in order) are line[1:-1]\n        place_order = line[1:-1]\n         # current holes (empty vertices) from a\n        holes = [v for v in range(1, n+1) if token_at[v] == 0]\n        assert len(holes) == 2\n        moves = []\n        # Helper: move one hole to target vertex \"u\" along the path \"line\",\n        # without crossing into already-placed prefix (min_idx = index of current v),\n        # and without crossing the chosen token position p (so we always stay\n        # in the same side of p as u).\n        def move_hole_to(u, p=None, min_idx=0):\n            nonlocal holes, token_at, pos_of, moves\n            up = idx[u]\n            i1 = idx[holes[0]]\n            i2 = idx[holes[1]]\n             # If one hole already there, done.\n            if holes[0] == u or holes[1] == u:\n                return\n             # decide the component side relative to p (if provided)\n            def valid_side(i):\n                if p is None:\n                    return True\n                pp = idx[p]\n                if up < pp:\n                    return i <= pp - 1\n                else:\n                    return i >= pp + 1\n            candidates = []\n            for hid, ii in [(0, i1), (1, i2)]:\n                if ii >= min_idx and valid_side(ii):\n                    candidates.append((abs(ii - up), hid, ii))\n            # In our flow there should always be at least one candidate\n            if not candidates:\n                # Fallback: if something unexpected, ignore p constraint\n                for hid, ii in [(0, i1), (1, i2)]:\n                    if ii >= min_idx:\n                        candidates.append((abs(ii - up), hid, ii))\n                assert candidates, \"No hole available to move.\"\n            candidates.sort()\n            _, active, i = candidates[0]\n            other = 1 - active\n            other_i = idx[holes[other]]\n            while i != up:\n                step = 1 if up > i else -1\n                j = i + step\n                vj = line[j]\n                 # if next step is the other hole, just \"switch\" active hole\n                if vj == holes[other]:\n                    i = j\n                    active, other = other, active\n                    other_i = idx[holes[other]]\n                    continue\n                 # move token from vj -> line[i] (the current hole position)\n                tok = token_at[vj]\n                assert tok != 0, \"Unexpected empty encountered.\"\n                vi = line[i]\n                # perform move\n                moves.append((tok, vi))\n                token_at[vi] = tok\n                token_at[vj] = 0\n                pos_of[tok] = vi\n                # hole has moved to vj\n                holes[active] = vj\n                i = j\n         # Prepare: put both holes to the very left side (L and L+1),\n        # so we never need to cross placed prefix later.\n        move_hole_to(L, p=None, min_idx=0)\n        move_hole_to(line[1], p=L, min_idx=0)  # moves the \"other\" hole to L+1\n         # Place tokens from left to right along the path\n        for v in place_order:\n            want = inv_target[v]          # token id that must end at v\n            p = pos_of[want]              # current position of that token\n            while p != v:\n                pi = idx[p]\n                # move to its left neighbor in the path\n                u = line[pi - 1]          # left neighbor exists because p != v\n                # ensure a hole at u; restrict holes to the unprocessed suffix\n                min_idx = idx[v]          # never cross placed prefix [1..idx[v]-1]\n                move_hole_to(u, p=p, min_idx=min_idx)\n                # now move the token one step left: p -> u\n                moves.append((want, u))\n                token_at[u] = want\n                token_at[p] = 0\n                pos_of[want] = u\n                # update which hole moved: the hole currently at u becomes at p\n                if holes[0] == u:\n                    holes[0] = p\n                else:\n                    assert holes[1] == u\n                    holes[1] = p\n                p = u\n         # collect output\n        out_lines.append(str(len(moves)))\n        all_moves.extend(moves)\n        for tok, where in moves:\n            out_lines.append(f\"{tok} {where}\")\n    print(\"\\n\".join(out_lines))\nif __name__ == \"__main__\":\n    solve()"
    },
    "325525900": {
      "id": 325525900,
      "creationTimeSeconds": 1750579246,
      "relativeTimeSeconds": 346,
      "programmingLanguage": "Python 3",
      "verdict": "WRONG_ANSWER",
      "testset": "TESTS",
      "passedTestCount": 1,
      "timeConsumedMillis": 62,
      "memoryConsumedBytes": 409600,
      "code": "import sys\ndef solve():\n    it = iter(sys.stdin.read().split())\n    t = int(next(it))\n    out_lines = []\n    all_moves = []\n    for _ in range(t):\n        n = int(next(it)); m = int(next(it))\n        a = [int(next(it)) for _ in range(n-2)]\n        b = [int(next(it)) for _ in range(n-2)]\n        # read and ignore extra edges (we only use the cycle edges)\n        for __ in range(m):\n            _u = next(it); _v = next(it)\n         # occupancy\n        token_at = [0]*(n+1)          # 0 if empty, else token id\n        pos_of = [0]*(n-1)            # token id -> vertex (1..n)\n        for i, v in enumerate(a, 1):\n            token_at[v] = i\n            pos_of[i] = v\n         # inverse targets: which token belongs at vertex v\n        inv_target = [0]*(n+1)\n        for i, v in enumerate(b, 1):\n            inv_target[v] = i\n         # final empty vertices = not in b\n        allv = set(range(1, n+1))\n        holes_final = list(allv - set(b))  # size 2\n        h1, h2 = holes_final[0], holes_final[1]\n         # choose orientation so that walking +1 from L to R covers n-2 vertices\n        def inc(x): \n            y = x + 1\n            if y > n: y = 1\n            return y\n        def dec(x):\n            y = x - 1\n            if y < 1: y = n\n            return y\n         # distance clockwise from u to v (#steps of inc to reach v)\n        def dist_cw(u, v):\n            if v >= u: return v - u\n            return v + n - u\n        if dist_cw(h1, h2) == 1:\n            L, R = h2, h1\n        else:\n            L, R = h1, h2\n         # Build the linear order \"line\": [L, L+1, ..., R] (no wrap between R->L)\n        line = []\n        x = L\n        while True:\n            line.append(x)\n            if x == R:\n                break\n            x = inc(x)\n        idx = {v: i for i, v in enumerate(line)}  # vertex -> index in line\n        # The vertices to place (in order) are line[1:-1]\n        place_order = line[1:-1]\n         # current holes (empty vertices) from a\n        holes = [v for v in range(1, n+1) if token_at[v] == 0]\n        assert len(holes) == 2\n        moves = []\n        # Helper: move one hole to target vertex \"u\" along the path \"line\",\n        # without crossing into already-placed prefix (min_idx = index of current v),\n        # and without crossing the chosen token position p (so we always stay\n        # in the same side of p as u).\n        def move_hole_to(u, p=None, min_idx=0):\n            nonlocal holes, token_at, pos_of, moves\n            up = idx[u]\n            i1 = idx[holes[0]]\n            i2 = idx[holes[1]]\n             # If one hole already there, done.\n            if holes[0] == u or holes[1] == u:\n                return\n             # decide the component side relative to p (if provided)\n            def valid_side(i):\n                if p is None:\n                    return True\n                pp = idx[p]\n                if up < pp:\n                    return i <= pp - 1\n                else:\n                    return i >= pp + 1\n            candidates = []\n            for hid, ii in [(0, i1), (1, i2)]:\n                if ii >= min_idx and valid_side(ii):\n                    candidates.append((abs(ii - up), hid, ii))\n            # In our flow there should always be at least one candidate\n            if not candidates:\n                # Fallback: if something unexpected, ignore p constraint\n                for hid, ii in [(0, i1), (1, i2)]:\n                    if ii >= min_idx:\n                        candidates.append((abs(ii - up), hid, ii))\n                assert candidates, \"No hole available to move.\"\n            candidates.sort()\n            _, active, i = candidates[0]\n            other = 1 - active\n            other_i = idx[holes[other]]\n            while i != up:\n                step = 1 if up > i else -1\n                j = i + step\n                vj = line[j]\n                 # if next step is the other hole, just \"switch\" active hole\n                if vj == holes[other]:\n                    i = j\n                    active, other = other, active\n                    other_i = idx[holes[other]]\n                    continue\n                 # move token from vj -> line[i] (the current hole position)\n                tok = token_at[vj]\n                assert tok != 0, \"Unexpected empty encountered.\"\n                vi = line[i]\n                # perform move\n                moves.append((tok, vi))\n                token_at[vi] = tok\n                token_at[vj] = 0\n                pos_of[tok] = vi\n                # hole has moved to vj\n                holes[active] = vj\n                i = j\n         # Prepare: put both holes to the very left side (L and L+1),\n        # so we never need to cross placed prefix later.\n        move_hole_to(L, p=None, min_idx=0)\n        move_hole_to(line[1], p=L, min_idx=0)  # moves the \"other\" hole to L+1\n         # Place tokens from left to right along the path\n        for v in place_order:\n            want = inv_target[v]          # token id that must end at v\n            p = pos_of[want]              # current position of that token\n            while p != v:\n                pi = idx[p]\n                # move to its left neighbor in the path\n                u = line[pi - 1]          # left neighbor exists because p != v\n                # ensure a hole at u; restrict holes to the unprocessed suffix\n                min_idx = idx[v]          # never cross placed prefix [1..idx[v]-1]\n                move_hole_to(u, p=p, min_idx=min_idx)\n                # now move the token one step left: p -> u\n                moves.append((want, u))\n                token_at[u] = want\n                token_at[p] = 0\n                pos_of[want] = u\n                # update which hole moved: the hole currently at u becomes at p\n                if holes[0] == u:\n                    holes[0] = p\n                else:\n                    assert holes[1] == u\n                    holes[1] = p\n                p = u\n         # collect output\n        out_lines.append(str(len(moves)))\n        all_moves.extend(moves)\n        for tok, where in moves:\n            out_lines.append(f\"{tok} {where}\")\n    print(\"\\n\".join(out_lines))\nif __name__ == \"__main__\":\n    solve()"
    },
    "325525762": {
      "id": 325525762,
      "creationTimeSeconds": 1750579175,
      "relativeTimeSeconds": 275,
      "programmingLanguage": "Python 3",
      "verdict": "WRONG_ANSWER",
      "testset": "TESTS",
      "passedTestCount": 1,
      "timeConsumedMillis": 77,
      "memoryConsumedBytes": 716800,
      "code": "import sys\ndef solve():\n    it = iter(sys.stdin.read().split())\n    t = int(next(it))\n    out_lines = []\n    all_moves = []\n    for _ in range(t):\n        n = int(next(it)); m = int(next(it))\n        a = [int(next(it)) for _ in range(n-2)]\n        b = [int(next(it)) for _ in range(n-2)]\n        # read and ignore extra edges (we only use the cycle edges)\n        for __ in range(m):\n            _u = next(it); _v = next(it)\n         # occupancy\n        token_at = [0]*(n+1)          # 0 if empty, else token id\n        pos_of = [0]*(n-1)            # token id -> vertex (1..n)\n        for i, v in enumerate(a, 1):\n            token_at[v] = i\n            pos_of[i] = v\n         # inverse targets: which token belongs at vertex v\n        inv_target = [0]*(n+1)\n        for i, v in enumerate(b, 1):\n            inv_target[v] = i\n         # final empty vertices = not in b\n        allv = set(range(1, n+1))\n        holes_final = list(allv - set(b))  # size 2\n        h1, h2 = holes_final[0], holes_final[1]\n         # choose orientation so that walking +1 from L to R covers n-2 vertices\n        def inc(x): \n            y = x + 1\n            if y > n: y = 1\n            return y\n        def dec(x):\n            y = x - 1\n            if y < 1: y = n\n            return y\n         # distance clockwise from u to v (#steps of inc to reach v)\n        def dist_cw(u, v):\n            if v >= u: return v - u\n            return v + n - u\n        if dist_cw(h1, h2) == 1:\n            L, R = h2, h1\n        else:\n            L, R = h1, h2\n         # Build the linear order \"line\": [L, L+1, ..., R] (no wrap between R->L)\n        line = []\n        x = L\n        while True:\n            line.append(x)\n            if x == R:\n                break\n            x = inc(x)\n        idx = {v: i for i, v in enumerate(line)}  # vertex -> index in line\n        # The vertices to place (in order) are line[1:-1]\n        place_order = line[1:-1]\n         # current holes (empty vertices) from a\n        holes = [v for v in range(1, n+1) if token_at[v] == 0]\n        assert len(holes) == 2\n        moves = []\n        # Helper: move one hole to target vertex \"u\" along the path \"line\",\n        # without crossing into already-placed prefix (min_idx = index of current v),\n        # and without crossing the chosen token position p (so we always stay\n        # in the same side of p as u).\n        def move_hole_to(u, p=None, min_idx=0):\n            nonlocal holes, token_at, pos_of, moves\n            up = idx[u]\n            i1 = idx[holes[0]]\n            i2 = idx[holes[1]]\n             # If one hole already there, done.\n            if holes[0] == u or holes[1] == u:\n                return\n             # decide the component side relative to p (if provided)\n            def valid_side(i):\n                if p is None:\n                    return True\n                pp = idx[p]\n                if up < pp:\n                    return i <= pp - 1\n                else:\n                    return i >= pp + 1\n            candidates = []\n            for hid, ii in [(0, i1), (1, i2)]:\n                if ii >= min_idx and valid_side(ii):\n                    candidates.append((abs(ii - up), hid, ii))\n            # In our flow there should always be at least one candidate\n            if not candidates:\n                # Fallback: if something unexpected, ignore p constraint\n                for hid, ii in [(0, i1), (1, i2)]:\n                    if ii >= min_idx:\n                        candidates.append((abs(ii - up), hid, ii))\n                assert candidates, \"No hole available to move.\"\n            candidates.sort()\n            _, active, i = candidates[0]\n            other = 1 - active\n            other_i = idx[holes[other]]\n            while i != up:\n                step = 1 if up > i else -1\n                j = i + step\n                vj = line[j]\n                 # if next step is the other hole, just \"switch\" active hole\n                if vj == holes[other]:\n                    i = j\n                    active, other = other, active\n                    other_i = idx[holes[other]]\n                    continue\n                 # move token from vj -> line[i] (the current hole position)\n                tok = token_at[vj]\n                assert tok != 0, \"Unexpected empty encountered.\"\n                vi = line[i]\n                # perform move\n                moves.append((tok, vi))\n                token_at[vi] = tok\n                token_at[vj] = 0\n                pos_of[tok] = vi\n                # hole has moved to vj\n                holes[active] = vj\n                i = j\n         # Prepare: put both holes to the very left side (L and L+1),\n        # so we never need to cross placed prefix later.\n        move_hole_to(L, p=None, min_idx=0)\n        move_hole_to(line[1], p=L, min_idx=0)  # moves the \"other\" hole to L+1\n         # Place tokens from left to right along the path\n        for v in place_order:\n            want = inv_target[v]          # token id that must end at v\n            p = pos_of[want]              # current position of that token\n            while p != v:\n                pi = idx[p]\n                # move to its left neighbor in the path\n                u = line[pi - 1]          # left neighbor exists because p != v\n                # ensure a hole at u; restrict holes to the unprocessed suffix\n                min_idx = idx[v]          # never cross placed prefix [1..idx[v]-1]\n                move_hole_to(u, p=p, min_idx=min_idx)\n                # now move the token one step left: p -> u\n                moves.append((want, u))\n                token_at[u] = want\n                token_at[p] = 0\n                pos_of[want] = u\n                # update which hole moved: the hole currently at u becomes at p\n                if holes[0] == u:\n                    holes[0] = p\n                else:\n                    assert holes[1] == u\n                    holes[1] = p\n                p = u\n         # collect output\n        out_lines.append(str(len(moves)))\n        all_moves.extend(moves)\n        for tok, where in moves:\n            out_lines.append(f\"{tok} {where}\")\n    print(\"\\n\".join(out_lines))\nif __name__ == \"__main__\":\n    solve()"
    },
    "325525436": {
      "id": 325525436,
      "creationTimeSeconds": 1750579034,
      "relativeTimeSeconds": 134,
      "programmingLanguage": "Python 3",
      "verdict": "WRONG_ANSWER",
      "testset": "TESTS",
      "passedTestCount": 1,
      "timeConsumedMillis": 61,
      "memoryConsumedBytes": 614400,
      "code": "import sys\ndef solve():\n    it = iter(sys.stdin.read().split())\n    t = int(next(it))\n    out_lines = []\n    all_moves = []\n    for _ in range(t):\n        n = int(next(it)); m = int(next(it))\n        a = [int(next(it)) for _ in range(n-2)]\n        b = [int(next(it)) for _ in range(n-2)]\n        # read and ignore extra edges (we only use the cycle edges)\n        for __ in range(m):\n            _u = next(it); _v = next(it)\n         # occupancy\n        token_at = [0]*(n+1)          # 0 if empty, else token id\n        pos_of = [0]*(n-1)            # token id -> vertex (1..n)\n        for i, v in enumerate(a, 1):\n            token_at[v] = i\n            pos_of[i] = v\n         # inverse targets: which token belongs at vertex v\n        inv_target = [0]*(n+1)\n        for i, v in enumerate(b, 1):\n            inv_target[v] = i\n         # final empty vertices = not in b\n        allv = set(range(1, n+1))\n        holes_final = list(allv - set(b))  # size 2\n        h1, h2 = holes_final[0], holes_final[1]\n         # choose orientation so that walking +1 from L to R covers n-2 vertices\n        def inc(x): \n            y = x + 1\n            if y > n: y = 1\n            return y\n        def dec(x):\n            y = x - 1\n            if y < 1: y = n\n            return y\n         # distance clockwise from u to v (#steps of inc to reach v)\n        def dist_cw(u, v):\n            if v >= u: return v - u\n            return v + n - u\n        if dist_cw(h1, h2) == 1:\n            L, R = h2, h1\n        else:\n            L, R = h1, h2\n         # Build the linear order \"line\": [L, L+1, ..., R] (no wrap between R->L)\n        line = []\n        x = L\n        while True:\n            line.append(x)\n            if x == R:\n                break\n            x = inc(x)\n        idx = {v: i for i, v in enumerate(line)}  # vertex -> index in line\n        # The vertices to place (in order) are line[1:-1]\n        place_order = line[1:-1]\n         # current holes (empty vertices) from a\n        holes = [v for v in range(1, n+1) if token_at[v] == 0]\n        assert len(holes) == 2\n        moves = []\n        # Helper: move one hole to target vertex \"u\" along the path \"line\",\n        # without crossing into already-placed prefix (min_idx = index of current v),\n        # and without crossing the chosen token position p (so we always stay\n        # in the same side of p as u).\n        def move_hole_to(u, p=None, min_idx=0):\n            nonlocal holes, token_at, pos_of, moves\n            up = idx[u]\n            i1 = idx[holes[0]]\n            i2 = idx[holes[1]]\n             # If one hole already there, done.\n            if holes[0] == u or holes[1] == u:\n                return\n             # decide the component side relative to p (if provided)\n            def valid_side(i):\n                if p is None:\n                    return True\n                pp = idx[p]\n                if up < pp:\n                    return i <= pp - 1\n                else:\n                    return i >= pp + 1\n            candidates = []\n            for hid, ii in [(0, i1), (1, i2)]:\n                if ii >= min_idx and valid_side(ii):\n                    candidates.append((abs(ii - up), hid, ii))\n            # In our flow there should always be at least one candidate\n            if not candidates:\n                # Fallback: if something unexpected, ignore p constraint\n                for hid, ii in [(0, i1), (1, i2)]:\n                    if ii >= min_idx:\n                        candidates.append((abs(ii - up), hid, ii))\n                assert candidates, \"No hole available to move.\"\n            candidates.sort()\n            _, active, i = candidates[0]\n            other = 1 - active\n            other_i = idx[holes[other]]\n            while i != up:\n                step = 1 if up > i else -1\n                j = i + step\n                vj = line[j]\n                 # if next step is the other hole, just \"switch\" active hole\n                if vj == holes[other]:\n                    i = j\n                    active, other = other, active\n                    other_i = idx[holes[other]]\n                    continue\n                 # move token from vj -> line[i] (the current hole position)\n                tok = token_at[vj]\n                assert tok != 0, \"Unexpected empty encountered.\"\n                vi = line[i]\n                # perform move\n                moves.append((tok, vi))\n                token_at[vi] = tok\n                token_at[vj] = 0\n                pos_of[tok] = vi\n                # hole has moved to vj\n                holes[active] = vj\n                i = j\n         # Prepare: put both holes to the very left side (L and L+1),\n        # so we never need to cross placed prefix later.\n        move_hole_to(L, p=None, min_idx=0)\n        move_hole_to(line[1], p=L, min_idx=0)  # moves the \"other\" hole to L+1\n         # Place tokens from left to right along the path\n        for v in place_order:\n            want = inv_target[v]          # token id that must end at v\n            p = pos_of[want]              # current position of that token\n            while p != v:\n                pi = idx[p]\n                # move to its left neighbor in the path\n                u = line[pi - 1]          # left neighbor exists because p != v\n                # ensure a hole at u; restrict holes to the unprocessed suffix\n                min_idx = idx[v]          # never cross placed prefix [1..idx[v]-1]\n                move_hole_to(u, p=p, min_idx=min_idx)\n                # now move the token one step left: p -> u\n                moves.append((want, u))\n                token_at[u] = want\n                token_at[p] = 0\n                pos_of[want] = u\n                # update which hole moved: the hole currently at u becomes at p\n                if holes[0] == u:\n                    holes[0] = p\n                else:\n                    assert holes[1] == u\n                    holes[1] = p\n                p = u\n         # collect output\n        out_lines.append(str(len(moves)))\n        all_moves.extend(moves)\n        for tok, where in moves:\n            out_lines.append(f\"{tok} {where}\")\n    print(\"\\n\".join(out_lines))\nif __name__ == \"__main__\":\n    solve()"
    },
    "336567356": {
      "id": 336567356,
      "creationTimeSeconds": 1756779922,
      "relativeTimeSeconds": 2147483647,
      "programmingLanguage": "Python 3",
      "verdict": "WRONG_ANSWER",
      "testset": "TESTS",
      "passedTestCount": 1,
      "timeConsumedMillis": 77,
      "memoryConsumedBytes": 819200,
      "code": "import sys\nfrom collections import deque\n\n# ---------- \uc720\ud2f8: BFS\ub85c \uacbd\ub85c \uad6c\ud558\uae30 ----------\ndef bfs_path(start, goal, adj, blocked):\n    \"\"\"\n    start -> goal \uae4c\uc9c0\uc758 \uc815\uc810 \uacbd\ub85c(\ud3ec\ud568)\ub97c \ubc18\ud658.\n    blocked[v]\uac00 True\uc778 \uc815\uc810\uc740 \ud1b5\uacfc \ubd88\uac00. \ub2e8, goal\uc740 \ud56d\uc0c1 \ud1b5\uacfc \ud5c8\uc6a9.\n    start\ub3c4 \ud1b5\uacfc \ud5c8\uc6a9.\n    \"\"\"\n    if start == goal:\n        return [start]\n    n = len(adj) - 1\n    prev = [-1] * (n + 1)\n    q = deque([start])\n    prev[start] = -2  # \uc2dc\uc791 \ud45c\uc2dc\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if prev[v] != -1:\n                continue\n            if blocked[v] and v != goal:\n                continue\n            prev[v] = u\n            if v == goal:\n                # \uacbd\ub85c \ubcf5\uc6d0\n                path = []\n                cur = goal\n                while cur != -2:\n                    path.append(cur)\n                    cur = prev[cur]\n                path.reverse()\n                return path\n            q.append(v)\n    # \ubb38\uc81c \uc870\uac74\uc0c1 \ud56d\uc0c1 \uac00\ub2a5\n    raise RuntimeError(\"No path found (should not happen).\")\n\ndef bfs_to_make_empty(target, adj, blocked, empty_set):\n    \"\"\"\n    \ube48 \uce78\ub4e4\uc744 \ub3d9\uc2dc\uc5d0 \uc2dc\uc791\uc810\uc73c\ub85c \ud558\uc5ec target\uc744 \ube48 \uce78\uc73c\ub85c \ub9cc\ub4dc\ub294 \uacbd\ub85c(\ube48 \uce78 \uc774\ub3d9 \uacbd\ub85c)\ub97c \ubc18\ud658.\n    \ubc18\ud658\uc740 'source_empty -> ... -> target' \uc815\uc810 \ub9ac\uc2a4\ud2b8.\n    blocked[v]\uac00 True\uc778 \uacf3\uc740 \ud1b5\uacfc \uae08\uc9c0. \ub2e8, target\uc740 \ud5c8\uc6a9.\n    empty_set\uc740 \ud604\uc7ac \ube48 \uce78 2\uac1c\uc758 \uc9d1\ud569.\n    \"\"\"\n    if target in empty_set:\n        return [target]  # \uc774\ubbf8 \ube48 \uce78\n\n    n = len(adj) - 1\n    prev = [-1] * (n + 1)\n    q = deque()\n    # \ub450 \ube48 \uce78\uc744 \uba40\ud2f0 \uc18c\uc2a4\ub85c\n    for s in empty_set:\n        prev[s] = -2  # \uc18c\uc2a4 \ud45c\uc2dd\n        q.append(s)\n\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if prev[v] != -1:\n                continue\n            if blocked[v] and v != target:\n                continue\n            prev[v] = u\n            if v == target:\n                # \uacbd\ub85c \ubcf5\uc6d0\n                path = []\n                cur = target\n                while cur != -2:\n                    path.append(cur)\n                    cur = prev[cur]\n                path.reverse()\n                return path\n            q.append(v)\n    raise RuntimeError(\"No empty path (should not happen).\")\n\n# ---------- \uba54\uc778 \ud574\uacb0 ----------\ndef solve():\n    data = [\"1\", \"4\", \"1\", \"1\", \"3\", \"2\", \"1\", \"2\", \"4\"]\n    it = iter(data)\n    t = int(next(it))\n    out_lines = []\n    for _case in range(t):\n        n = int(next(it)); m = int(next(it))\n        T = n - 2  # \ud1a0\ud070 \uc218\n\n        a = [int(next(it)) for _ in range(T)]\n        b = [int(next(it)) for _ in range(T)]\n\n        # \uadf8\ub798\ud504 \uc778\uc811\ub9ac\uc2a4\ud2b8(1-indexed)\n        adj = [set() for _ in range(n + 1)]\n        # \uc0ac\uc774\ud074 \uac04\uc120\n        for i in range(1, n + 1):\n            u = i\n            v = i + 1 if i < n else 1\n            adj[u].add(v)\n            adj[v].add(u)\n        # \ucd94\uac00 \uac04\uc120\n        for _ in range(m):\n            u = int(next(it)); v = int(next(it))\n            adj[u].add(v); adj[v].add(u)\n        # set -> list\n        adj = [list(nei) for nei in adj]\n\n        # \uc0ac\uc774\ud074\uc758 \uc21c\uc11c \uad00\ub9ac\uc6a9(next/prev)\n        nxt = [0] * (n + 1)\n        prv = [0] * (n + 1)\n        for i in range(1, n + 1):\n            nxt[i] = i + 1 if i < n else 1\n            prv[i] = i - 1 if i > 1 else n\n\n        # \uc810\uc720 \uc0c1\ud0dc \ubc0f \ud1a0\ud070 \uc704\uce58\n        occ = [0] * (n + 1)          # occ[v] = \ud1a0\ud070 \ubc88\ud638 \ub610\ub294 0(\ube48\uce78)\n        pos = [0] * (T + 1)          # pos[t] = \ud1a0\ud070 t\uc758 \ud604\uc7ac \uc815\uc810\n        for tkn in range(1, T + 1):\n            v = a[tkn - 1]\n            occ[v] = tkn\n            pos[tkn] = v\n\n        # \ud604\uc7ac \ube48 \uce78 2\uac1c\n        empty_set = set(v for v in range(1, n + 1) if occ[v] == 0)\n        assert len(empty_set) == 2\n\n        # \uac01 \uc815\uc810\uc758 \ubaa9\ud45c \ud1a0\ud070 id\n        token_by_target = [0] * (n + 1)\n        for tkn in range(1, T + 1):\n            token_by_target[b[tkn - 1]] = tkn\n\n        # \ucd5c\uc885 \ube48 \uce78 \uc704\uce58(\ubaa9\ud45c b\uc5d0 \uc5c6\ub294 \ub450 \uc815\uc810)\n        target_set = set(b)\n        final_empties = set(range(1, n + 1)) - target_set\n        assert len(final_empties) == 2\n\n        fixed = [False] * (n + 1)   # \uc774\ubbf8 \uc81c\uc790\ub9ac\uc5d0 \ub454 \uc815\uc810\n        fixed_cnt = 0\n\n        moves = []  # (token, to_vertex) \uc800\uc7a5\n\n        def record_move(token_id, to_v):\n            \"\"\"\ud1a0\ud070 token_id\ub97c to_v\ub85c \uc2e4\uc81c\ub85c \ud55c \uce78 \uc774\ub3d9(\uc778\uc811). \ube48\uce78/\uc810\uc720 \uac31\uc2e0.\"\"\"\n            from_v = pos[token_id]\n            # to_v\ub294 \ubc18\ub4dc\uc2dc \ud604\uc7ac \ube44\uc5b4 \uc788\uc5b4\uc57c \ud568\n            # \uc778\uc811\uc740 BFS \uad6c\uc131\uc0c1 \ubcf4\uc7a5\n            occ[from_v] = 0\n            occ[to_v] = token_id\n            pos[token_id] = to_v\n            # \ube48 \uce78 \uac31\uc2e0\n            empty_set.remove(to_v)\n            empty_set.add(from_v)\n            moves.append((token_id, to_v))\n\n        def make_empty_at(x, token_pos_to_avoid):\n            \"\"\"\uc815\uc810 x\ub97c \ube48 \uce78\uc73c\ub85c \ub9cc\ub4e0\ub2e4. (\ube48 \uce78 \uacbd\ub85c BFS \ud6c4 \uc2ac\ub77c\uc774\ub4dc \uc2e4\ud589)\"\"\"\n            if occ[x] == 0:\n                return\n            blocked = [False] * (n + 1)\n            for v in range(1, n + 1):\n                if fixed[v]:\n                    blocked[v] = True\n            blocked[token_pos_to_avoid] = True  # \ud604\uc7ac \uc804\uc9c4 \ud1a0\ud070 \uc704\uce58\ub294 \uac74\ub4dc\ub9ac\uc9c0 \uc54a\uc74c\n\n            path = bfs_to_make_empty(x, adj, blocked, empty_set)\n            # path: source_empty -> ... -> x\n            # \ube48 \uce78\uc744 \ud55c \uce78\uc529 x\ub85c \ubcf4\ub0b8\ub2e4: (\ub2e4\uc74c \uce78\uc758 \ud1a0\ud070\uc744 \ud604\uc7ac \ube48 \uce78\uc73c\ub85c \uc774\ub3d9)\n            for i in range(len(path) - 1):\n                u = path[i]      # \ud604\uc7ac \ube48\uce78\n                v = path[i + 1]  # \ub2e4\uc74c \uc815\uc810(\uc5ec\uae30 \ud1a0\ud070\uc744 u\ub85c \uc774\ub3d9)\n                tok = occ[v]\n                # v\uac00 \ube48\uce78\uc77c \uc77c\uc740 \uc5c6\uc74c(\uba40\ud2f0\uc18c\uc2a4 \ucc98\ub9ac\ub85c \ub0b4\ubd80 \uacbd\ub85c\uc5d0 \ub2e4\ub978 \ube48\uce78\uc774 \uc548 \uc7a1\ud788\uac8c \ub428)\n                # \ub2e8, target\uc774 \uc6d0\ub798 \ube48\uce78\uc774\uba74 path \uae38\uc774\uac00 1\uc774\ub77c \ub8e8\ud504 \ubbf8\uc2e4\ud589\n                if tok == 0:\n                    # \ubc29\uc5b4\uc801 \uccb4\ud06c(\uc774\uc0c1 \ucf00\uc774\uc2a4 \ubc29\uc9c0)\n                    continue\n                record_move(tok, u)\n            # \uc774\uc81c x\uac00 \ube48 \uce78\uc774 \ub428\n\n        def move_token_to_vertex(token_id, target_v):\n            \"\"\"\ud1a0\ud070 token_id\ub97c target_v\ub85c \ubcf4\ub0b8\ub2e4(\uc5ec\ub7ec \uce78, BFS \uacbd\ub85c \ub530\ub77c \ud55c \uce78\uc529).\"\"\"\n            # \ud1a0\ud070 \uc774\ub3d9 \uacbd\ub85c\ub294 \uace0\uc815 \uc815\uc810\ub9cc \ud53c\ud558\uba74 \ub428\n            blocked = [False] * (n + 1)\n            for v in range(1, n + 1):\n                if fixed[v]:\n                    blocked[v] = True\n            # \uacbd\ub85c \uad6c\ud558\uae30 (\ud1a0\ud070\uc758 \ud604\uc7ac \uc704\uce58 -> \ubaa9\ud45c \uc815\uc810)\n            path = bfs_path(pos[token_id], target_v, adj, blocked)\n            # \ud55c \uce78\uc529 \uc804\uc9c4\n            for i in range(1, len(path)):\n                step = path[i]\n                # \uba3c\uc800 step\uc744 \ube44\uc6b0\uae30\n                make_empty_at(step, pos[token_id])\n                # \uc774\uc81c \ud1a0\ud070\uc744 \ud55c \uce78 \uc774\ub3d9\n                record_move(token_id, step)\n            # target_v\uc5d0 \ub3c4\ucc29\n\n        # \uace0\uc815 \uad6c\uac04 \uc591 \ub05d(\uc0ac\uc774\ud074 \uae30\uc900). \ucc98\uc74c\uc5d4 \uc544\ubb34\uac83\ub3c4 \uc5c6\uc73c\ub2c8 \ud558\ub098 \ubf51\uc544 \uc2dc\uc791\uc810 \uc124\uce58\n        # final_empties\uac00 \uc544\ub2cc \uc784\uc758\uc758 \uc815\uc810 \ud558\ub098\ub97c \uba3c\uc800 \uace0\uc815\n        first_v = next(v for v in range(1, n + 1) if v not in final_empties)\n        first_token = token_by_target[first_v]\n        if pos[first_token] != first_v:\n            move_token_to_vertex(first_token, first_v)\n        fixed[first_v] = True\n        fixed_cnt += 1\n        L = R = first_v  # \uace0\uc815 \uad6c\uac04: L .. R (next \ubc29\ud5a5\uc73c\ub85c \uc5f0\uc18d)\n\n        # \uc774\ud6c4\uc5d0\ub294 \uace0\uc815 \uad6c\uac04\uc758 \uc591 \uc606\uc5d0\uc11c\ub9cc \ud655\uc7a5\n        while fixed_cnt < n - 2:\n            y1 = nxt[R]\n            y2 = prv[L]\n            pick = None\n            if not fixed[y1] and y1 not in final_empties:\n                pick = y1\n            elif not fixed[y2] and y2 not in final_empties:\n                pick = y2\n            else:\n                # \ub458 \ub2e4 \ucd5c\uc885 \ube48\uce78\uc774\uba74 \ub05d(\ub450 \uac1c \ub0a8\uc74c)\n                break\n\n            tkn = token_by_target[pick]\n            if pos[tkn] != pick:\n                move_token_to_vertex(tkn, pick)\n            fixed[pick] = True\n            fixed_cnt += 1\n            if pick == y1:\n                R = pick\n            else:\n                L = pick\n\n        # \ucd9c\ub825\n        out_lines.append(str(len(moves)))\n        out_lines.extend(f\"{c} {p}\" for c, p in moves)\n\n    print(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()\n"
    }
  },
  "testcases": [
    {
      "no": 1,
      "input": "1\n4 1\n1 3\n2 1\n2 4",
      "expect": "4\n2 2\n1 4\n2 1\n1 2",
      "hasStdIn": true
    },
    {
      "no": 2,
      "hasStdIn": true,
      "input": "1\n8 2\n2 4 6 8 1 5\n6 8 4 2 5 7\n3 7\n1 4\n",
      "expect": "6\n1 3\n5 2\n4 1\n1 7\n5 3\n4 2"
    },
    {
      "no": 3,
      "hasStdIn": true,
      "input": "1\n6 1\n2 4 6 1\n4 6 1 3\n3 5\n",
      "expect": "5\n1 3\n4 2\n3 1\n2 5\n2 6"
    }
  ]
}