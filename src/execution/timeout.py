"""
Timeout decorator.

    :copyright: (c) 2012-2013 by PN.
    :license: MIT, see LICENSE for more details.
"""

from __future__ import print_function
from __future__ import unicode_literals
from __future__ import division

import sys
import time
import tracemalloc

import multiprocessing
import signal
from functools import wraps
from io import StringIO
from ordered_set import OrderedSet

from .results import Result

class TimeoutError(AssertionError):

    """Thrown when a timeout occurs in the `timeout` context manager."""

    def __init__(self, value="Timed Out"):
        self.value = value

    def __str__(self):
        return repr(self.value)


def _raise_exception(exception, exception_message):
    """ This function checks if a exception message is given.

    If there is no exception message, the default behaviour is maintained.
    If there is an exception message, the message is passed to the exception with the 'value' keyword.
    """
    if exception_message is None:
        raise exception()
    else:
        raise exception(exception_message)


def timeout(seconds=None, use_signals=True, timeout_exception=TimeoutError, exception_message=None):
    """Add a timeout parameter to a function and return it.

    :param seconds: optional time limit in seconds or fractions of a second. If None is passed, no timeout is applied.
        This adds some flexibility to the usage: you can disable timing out depending on the settings.
    :type seconds: float
    :param use_signals: flag indicating whether signals should be used for timing function out or the multiprocessing
        When using multiprocessing, timeout granularity is limited to 10ths of a second.
    :type use_signals: bool

    :raises: TimeoutError if time limit is reached

    It is illegal to pass anything other than a function as the first
    parameter. The function is wrapped and returned to the caller.
    """
    def decorate(function):

        if use_signals:
            def handler(signum, frame):
                _raise_exception(timeout_exception, exception_message)

            @wraps(function)
            def new_function(*args, **kwargs):
                new_seconds = kwargs.pop('timeout', seconds)
                if new_seconds:
                    old = signal.signal(signal.SIGALRM, handler)
                    signal.setitimer(signal.ITIMER_REAL, new_seconds)

                if not seconds:
                    return function(*args, **kwargs)

                try:
                    return function(*args, **kwargs)
                finally:
                    if new_seconds:
                        signal.setitimer(signal.ITIMER_REAL, 0)
                        signal.signal(signal.SIGALRM, old)
            return new_function
        else:
            @wraps(function)
            def new_function(*args, **kwargs):
                timeout_wrapper = _Timeout(function, timeout_exception, exception_message, seconds)
                return timeout_wrapper(*args, **kwargs)
            return new_function

    return decorate



class _Timeout(object):

    """Wrap a function and add a timeout (limit) attribute to it.

    Instances of this class are automatically generated by the add_timeout
    function defined above. Wrapping a function allows asynchronous calls
    to be made and termination of execution after a timeout has passed.
    """

    def __init__(self, function, timeout_exception, exception_message, limit):
        """Initialize instance in preparation for being called."""
        self.__limit = limit
        self.__function = function
        self.__timeout_exception = timeout_exception
        self.__exception_message = exception_message
        self.__name__ = function.__name__
        self.__doc__ = function.__doc__
        self.__timeout = time.process_time()
        # self.__process = multiprocessing.Process()
        # self.__queue = multiprocessing.Queue()
        
        self._str_cache = {}
        self._safe_str = str
        
        self.exec_traces = []
        self.vari_traces = {}
        self.before_mem = 0

    def localtrace(self, frame, why, arg):
        if frame.f_code.co_filename != "<string>":
            return self.localtrace
        if why == "line":
            lineno = frame.f_lineno
            if lineno <= Result.end_line:
                self.exec_traces.append(lineno)
            
            lineno -= 1
            if lineno not in Result.line_vari_map:
                return self.localtrace

            for k, v in frame.f_locals.items():
                if k not in Result.line_vari_map[lineno]: continue
                
                self.vari_traces.setdefault(k, {})
                self.vari_traces[k].setdefault(lineno, OrderedSet())
                vari_traces = self.vari_traces[k][lineno]
                
                last = vari_traces[-1] if vari_traces else None
                cache_key = (id(v), type(v), getattr(v, "__len__", lambda: None)())
                str_v = self._str_cache.get(cache_key)
                if str_v is None:
                    str_v = self._safe_str(v)
                    self._str_cache[cache_key] = str_v
                
                if last and last == str_v:
                    continue
                
                vari_traces.add(str_v)
        return self.localtrace
    
    def _target(self, queue, function, *args, **kwargs):
        trace = kwargs.pop('trace', False)
        orig_stdout, orig_stderr = sys.stdout, sys.stderr
        buf_out, buf_err = StringIO(), StringIO()
        sys.stdout, sys.stderr = buf_out, buf_err
        
        flag = False
        result = None
        exec_time = 0   # seconds
        mem_usage = 0   # megabytes
        
        try:
            if trace:
                tracemalloc.start()
                self.before_mem = tracemalloc.get_traced_memory()[1]
                start_time = time.process_time()
                sys.settrace(self.localtrace)
            result = function(*args, **kwargs)
            flag = True
        except Exception as e:
            result = e
        finally:
            if trace:
                exec_time = time.process_time() - start_time
                mem_usage = tracemalloc.get_traced_memory()[1] - self.before_mem
                tracemalloc.stop()
                sys.settrace(None)
        
        # bytes to megabytes
        mem_usage /= (1024 * 1024)
        
        queue.put((flag, result, buf_out.getvalue(), buf_err.getvalue(), 
                    exec_time, mem_usage, self.exec_traces, self.vari_traces))
        sys.stdout, sys.stderr = orig_stdout, orig_stderr
            
        
    def __call__(self, *args, **kwargs):
        self.__limit = kwargs.pop('timeout', self.__limit)
        self.__queue = multiprocessing.Queue(1)
        proc_args = (self.__queue, self.__function) + args
        self.__process = multiprocessing.Process(target=self._target,
                                                 args=proc_args,
                                                 kwargs=kwargs)
        self.__process.daemon = True
        self.__process.start()

        if self.__limit is not None:
            self.__timeout = time.process_time() + self.__limit

        while not self.ready:
            time.sleep(0.00000001)

        flag, payload, out, err, exec_time, mem_usage, exec_traces, vari_traces = self.__queue.get()
        
        sys.stdout.write(out)
        sys.stderr.write(err)
        Result.exec_time = exec_time
        Result.mem_usage = mem_usage
        Result.exec_traces = exec_traces
        Result.vari_traces = vari_traces

        if flag:
            return payload
        else:
            raise payload

    def cancel(self):
        """Terminate any possible execution of the embedded function."""
        if self.__process.is_alive():
            self.__process.terminate()

        _raise_exception(self.__timeout_exception, self.__exception_message)

    @property
    def ready(self):
        """Read-only property indicating status of "value" property."""
        if self.__limit and self.__timeout < time.process_time():
            self.cancel()
        return self.__queue.full() and not self.__queue.empty()

    @property
    def value(self):
        """Read-only property containing data returned from function."""
        if self.ready is True:
            flag, load = self.__queue.get()
            if flag:
                return load
            raise load
        